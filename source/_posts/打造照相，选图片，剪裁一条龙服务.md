---
title: 打造照相，选图片，剪裁一条龙服务
date: 2016-03-23 19:54:30
tags:
  - Android
  - 功能模块化
---
在我做过的项目中，几乎都会有用户定制头像的功能，今天我们就来介绍一下头像模块的制作，该模块非常精简，就一个文件，但是功能齐全，能满足头像功能的基本需求，可扩展性强，用户可根据具体需求进一步拓展。

# 需求分析

首先让我们来回忆一下平时上传头像的步骤吧，第一步肯定是在“我的”页面里会看到一个默认头像，然后我们的第一反应是它可以点，当点击它之后会给出我们选择，是拍照还是选取本地图片，由于源图片的大小形状不一，所以我们需要对原始图片进行处理，比如说剪裁和缩放，最后再将生成的裁剪图片上传。

有了上述基本需求后，我们再抽象出几个主要的功能点：

1. 拍照
2. 选取本地图片
3. 剪裁
4. 缩放
5. 上传

# 主要功能点实现

## 拍照

头像的来源可以是新拍的照片，这里我们写一个函数调用系统的拍照功能。

``` Java
    public void takePhoto() {
        Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
        intent.putExtra(MediaStore.EXTRA_OUTPUT, originUri);//设置拍照后的输出位置
        activity.startActivityForResult(intent, TAKE_PHOTO);
    }
```

在启动Activity前需要指定一下输出路径，它是一个uri，照下来的图片就会存储在这个指定的路径里，如何去获取这个路径我们后面再说。由于它是一个系统提供的Activity，且调用方式是`startActivityForResult()`，所以需要在启动它的Activity里重写`public void onActivityResult(int requestCode, int resultCode, Intent result)`来进一步处理，具体如何写在后文会介绍，我们先继续往下看。

## 选取本地图片

用户也有可能想选择一张手机里已有的照片，这时候需要调用系统的选择器。

``` Java
    public void selectPhoto() {
        Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
        intent.setType("image/*");//指定选择文件的类型
        activity.startActivityForResult(intent, SELECT_PHOTO);
    }
```

这里的逻辑基本和拍照类似，所以不再赘述，但是需要注意一点，如果和上面一样设置输出位置的话`intent.putExtra(MediaStore.EXTRA_OUTPUT, originUri);`，不会有任何效果，后面我们会针对此现象有特殊处理。由于我们只需要图片文件，所以指定过滤条件为图片类型。

## 剪裁

头像一般都有固定的宽高比，我们用`aspectX`和`aspectY`这两个int来代表，当为0:0时代表可以自由调整宽高比，接下来同样是调用系统的剪裁功能。

``` java
    public void cropPhoto() {
        Intent intent = new Intent("com.android.camera.action.CROP");
        intent.setDataAndType(originUri, "image/*");//原图路径
        intent.putExtra("crop", "true");
        intent.putExtra("aspectX", aspectX);
        intent.putExtra("aspectY", aspectY);
        intent.putExtra("scale", true);//是否保留比例
        intent.putExtra(MediaStore.EXTRA_OUTPUT, cropUri);//输出路径
        intent.putExtra("return-data", false);//是否将剪裁后的bitmap放在data里返回
        intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString());//输出格式
        intent.putExtra("noFaceDetection", true);//关闭人脸检测
        activity.startActivityForResult(intent, CROP_PHOTO);
    }
```

如果读者有兴趣的话，可以看看这篇文章[【译】如何使用Android MediaStore裁剪大图片](http://my.oschina.net/ryanhoo/blog/86843)。在这里要说的是` intent.putExtra("return-data", false);`这一句，如果不加这句，默认是true，那么生成的剪裁图片会在`public void onActivityResult(int requestCode, int resultCode, Intent result)`的result中返回，获取方式是`(Bitmap)result.getExtras().getParcelable("data");`，但是这么做的话会有个问题，返回的bitmap有可能会被压缩而失真，为了得到剪裁过的原图，我们把生成的原图输出为jpeg格式的文件保存下来。

## 缩放

最后一个问题了，头像一般只是一张很小的图片，不需要特别高清的大图，那么我们现在就来把图片变小吧。定义一个函数，输入图片文件的地址，然后生成一张宽和高分别不大于`maxWidth`和`maxHeight`的bitmap。

``` Java
    private Bitmap sampleBitmap(Uri in) {
        BitmapFactory.Options opt = new BitmapFactory.Options();
        opt.inJustDecodeBounds = true;//不将图片载入内存，仅计算宽高
        String string = in.getPath();//获取输入图片地址
        BitmapFactory.decodeFile(string, opt);
        int w = opt.outWidth;
        int h = opt.outHeight;
        int sw = w / maxWidth;//宽的采样值
        int sh = h / maxHeight;//高的采样值
        opt.inJustDecodeBounds = false;//关掉仅计算宽高的标志位
        opt.inSampleSize = Math.max(Math.max(sw, sh), 1);//取宽采样值，高采样值，1三者的最大值
        return BitmapFactory.decodeFile(in.getPath(), opt);//采样获取bitmap
    }
```

这里用到了采样的方式，使用`Bitmap createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, int boolean filter)`也能达到缩放的效果，只不过后者需要把原图作为bitmap全部载入内存，如果图片很大会造成内存溢出错误。什么是采样呢？这么说吧，有一个数组[1,2,3,4,5,6,7,8,9,10]当采样值为2的时候，采样过的数组变为[1,3,5,7,9]也就是每取一个再跳过n-1个（n为采样值）。在图片的宽度方向和长度方向分别采样，得到的图片就是原来的n^2分之一。

## 上传

由于上传涉及到服务器的网络接口格式，本文不做讨论，我们只负责把生成的bitmap转换成一个文件就行了，不多说，代码如下：

``` Java
    private Uri bitmapToFile(Bitmap bm, Uri out) {
        if (bm == null) return null;
        try {
            BufferedOutputStream bos = new BufferedOutputStream(activity.getContentResolver().openOutputStream(out));
            bm.compress(Bitmap.CompressFormat.JPEG, 100, bos);
            bos.flush();
            bos.close();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
        return out;
    }
```

`resizeUri`是预先定义好的缩放图片对应的存放位置，我们首先得到它的输出流，然后将其用jpeg格式，用100%压缩率（不压缩），保存为文件，最后返回文件对应uri。

# 配置和回调部分的实现

光有上面那些功能函数还不是一个完整的模块，我们还需要将所有功能从某个具体的activity中其独立出来，解耦。由于我们的许多功能依赖于activity对象，所以我们必须得传一个activity对象进来。由于是必需的参量，所以在构造函数中就得传进来。

``` Java
    public TakeSelectCrop(Activity activity) {
        this.activity = activity;
        originUri = getPhotoFileUri(ORIGIN_FILENAME);//原始图片的uri
        cropUri = getPhotoFileUri(CROP_FILENAME);//裁剪过的图片的uri
        resizeUri = getPhotoFileUri(RESIZE_FILENAME);//缩放过的图片的uri
    }
```

图片数据是内存敏感的数据类型，所以我们尽量用文件进行操作，除了给activity变量赋值外，我们还初始化了三个关键的图片文件Uri，这里涉及到一个获取文件Uri的函数，注释中讲的很清楚了，我就不再赘述。

``` Java
    // 获取外存安全目录中指定文件名的uri
    private Uri getPhotoFileUri(String fileName) {
        String state = Environment.getExternalStorageState();
        // 外部存储设备挂载成功且有读写权限
        if (state.equals(Environment.MEDIA_MOUNTED)) {
            // 获取安全存储路径，getExternalFilesDir获取的是应用包名对应的外存目录，读写这个目录不需要声明外存读写权限
            File mediaStorageDir = new File(
                    activity.getExternalFilesDir(Environment.DIRECTORY_PICTURES), TAG);
            // 临时目录不存在就创建
            if (!mediaStorageDir.exists() && !mediaStorageDir.mkdirs()) {
                Log.d(TAG, "failed to create directory");
            }
            return Uri.fromFile(new File(mediaStorageDir.getPath() + File.separator + fileName));
        }
        return null;
    }
```

细心的读者可能会发现，图片的宽高比，最大高度，最大宽度还没定义呢，这些变量在构造函数中咋没初始化？我对于模块设计的理解是：

> 模块设计中，配置应该尽可能地简单，对于必需的参量在构造函数中传入，对于可选的参量，应该给一个默认值，如果模块使用者想自定义，也能够通过相关函数修改它，这样设计有两个好处：1.对于大部分场景，默认配置足够了，简单配置后开箱即用；2.有更好的向下兼容性，如果将来模块新增了功能，需要传入更多的参量，如果这些参量都是可选的话，那么我们不需要修改构造函数，只需要增加配置函数即可，使用旧版本模块的代码不需要做任何修改。

综上所述，图片的宽高比，最大高度，最大宽度我都作为可选参量，在初始化的时候赋一个默认值，再使用市面上流行的链式调用来配置，链式调用很好写，就是每次配置完一个参量后返回对象本身即可，调用起来也很方便，比如：`a(1).b(2).c(3).d(4)`;。如下展示了配置宽高比的函数，其他亦是如此，不再多写占篇幅。

``` Java
    public TakeSelectCrop setAspect(int x, int y) {
        this.aspectX = x;
        this.aspectY = y;
        return this;
    }
```

我们照相，选图，裁剪都是用了`startActivityForResult()`，所以需要在启动它的Activity里重写`public void onActivityResult(int requestCode, int resultCode, Intent result)`来进一步处理返回结果，但我们的模块类并不是继承的Activity类，所以不能重写`onActivityResult`，只能写个代理函数，再在activity中重写并调用这个代理函数

``` Java
    public void onActivityResult(int requestCode, int resultCode, Intent result) {
        switch (requestCode) {
            case TAKE_PHOTO:
                handleTake(requestCode, resultCode, result);
                break;
            case SELECT_PHOTO:
                handleSelect(requestCode, resultCode, result);
                break;
            case CROP_PHOTO:
                handleCrop(requestCode, resultCode, result);
                break;
            default:
                break;
        }
    }
```

对于3种操作都有进一步的处理，但再怎么处理也还是在我们的模块内处理，如果我们想在原来的activity中进行后续操作怎么办？相信读者已经看出这照相，选图，裁剪是一系列异步操作，说到异步，就想到回调，回调就是把activity中的逻辑传进我们的模块中，在达到某个触发条件的时候去执行这段逻辑，也就是设计模式中常用的模板方法模式。目前我们还缺个回调类，下面我们就定义它：

``` Java
    public interface Callback {
        void onTaked(Uri photoFileUri);//当拍照成功时回调

        void onSelected(Uri photoFileUri);//当选择成功时回调

        void onCropped(Uri photoFileUri);//当剪裁成功时回调

        void onResized(Uri photoFileUri);//当缩放成功时回调

        void onCanceled(int requestCode);//当取消时回调
    }
```

现在我们要传入回调接口的实例，它是一个可选参量，因此在初始化时候给一个默认的实现，再以链式调用方式提供配置函数即可，构造函数不需要任何的修改。

``` Java
    public TakeSelectCrop setCallback(Callback callback) {
        this.callback = callback;
        return this;
    }
```

至此，我们的头像模块已经基本成型，完整代码和使用方式都在github上，欢迎fork。