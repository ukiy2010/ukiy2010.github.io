---
title: 故事中的设计模式（一）工厂模式
tags:
  - 工厂模式
  - 设计模式
date: 2016-04-26 21:53:57
---


# 小明开店记

小明是XXX公司的一名程序员，每天上班的内容就是写代码，渐渐地他感到有些压抑，而且每天都很累，他想换一个工作。除了写代码，他还有一项拿手绝活，那就是做巧克力蛋糕。有一天小明突然想把自己做的巧克力蛋糕拿来卖，这样既可以让更多人尝到，又能创收。小明抄起家伙，说干就干：

``` Java
class ChocolateCake {}
public class Main {
    public static void main(String[] args) {
        ChocolateCake chocolateCake = new ChocolateCake();
    }
}
```

小明做的巧克力蛋糕确实又好看又好吃，大家尝过后都赞不绝口，一开业就全部卖光了，未雨绸缪的小明想，大家吃多了巧克力蛋糕会腻的吧，所以小明开始摸索新的蛋糕口味。经过一番研究后小明做出了慕斯蛋糕，水果蛋糕等许多口味的新品。

``` Java
class ChocolateCake {}
class MousseCake {}
class FruitCake {}
//还有很多种蛋糕种类...
public class Main {
    public static void main(String[] args) {
        ChocolateCake chocolateCake = new ChocolateCake();
        Cake mousseCake = new MousseCake();
        Cake fruitCake = new FruitCake();
        //还生成了很多种蛋糕
    }
}
```

设计出各种新口味后，蛋糕果然大卖，渐渐地，小明发现他每做一个蛋糕都要从头开始花很长时间去做，但是蛋糕坯的制作方法都是一样的，所以他开始想弄一个自动做蛋糕坯的机器，等做出蛋糕坯后，再加上其他原料做成各种口味的蛋糕。

``` Java
abstract class Cake {}//做蛋糕的相同步骤
class ChocolateCake extends Cake {}
class MousseCake extends Cake {}
class FruitCake extends Cake {}
class XiaoMing {//简单工厂（静态工厂），只有一个工厂

    public static Cake makeMousseCake() {
        return new MousseCake();
    }

    public static Cake makeChocolateCake() {
        return new ChocolateCake();
    }

    public static Cake makeFruitCake() {
        return new FruitCake();
    }
}
public class Main {
    public static void main(String[] args) {
        Cake chocolateCake = XiaoMing.makeChocolateCake();
        Cake mousseCake = XiaoMing.makeMousseCake();
        Cake fruitCake = XiaoMing.makeFruitCake();
    }
}
```

这下好了，小明如果又新发明了一种蛋糕，只需要在原来的蛋糕坯上放上新的原料即可。由于花样繁多又美味，小明的蛋糕非常受欢迎，越来越火爆，小明一个人忙不过来了，于是他收了两个徒弟，小李和小张，来帮他做。他们仨各做一种蛋糕。

``` Java
abstract class Cake {}//做蛋糕的相同步骤
class ChocolateCake extends Cake {}
class MousseCake extends Cake {}
class FruitCake extends Cake {}

interface ICakeMaker {//每个人的职责
    Cake makeCake();
}

class XiaoMing implements ICakeMaker{//工厂方法模式
    public Cake makeCake() {
        return new ChocolateCake();
    }
}

class XiaoLi implements ICakeMaker{
    public Cake makeCake() {
        return new MousseCake();
    }
}

class XiaoZhang implements ICakeMaker{
    public Cake makeCake() {
        return new FruitCake();
    }
}
public class Main {
    public static void main(String[] args) {
        ICakeMaker chocolateCakeMaker = new XiaoMing();
        ICakeMaker mousseCakeMaker = new XiaoLi();
        ICakeMaker fruitCakeMaker = new XiaoZhang();
        
        Cake chocolateCake = chocolateCakeMaker.makeCake();
        Cake mousseCake = mousseCakeMaker.makeCake();
        Cake fruitCake = fruitCakeMaker.makeCake();
    }
}
```

小明觉得自己可以做得更好，但是不知道如何改进，于是他对上门的顾客做了问卷调查，发现顾客想在买蛋糕的同时也能够买一些果汁，所以小明决定开展新业务，卖果汁！但是果汁和蛋糕的制作方法完全不一样，之前做蛋糕坯的机器根本用不上，所幸果汁的制作也是遵循一定的步骤，把这些相同的步骤拿出来交给机器做就好啦，于是小明又发明了一个果汁机器。他还让每个徒弟在原来制作蛋糕的任务上再负责制作一种果汁。

``` Java
abstract class Cake {}//做蛋糕的相同步骤
class ChocolateCake extends Cake {}
class MousseCake extends Cake {}
class FruitCake extends Cake {}

abstract class Juice {}//做果汁的相同步骤
class OrangeJuice extends Juice {}
class AppleJuice extends Juice {}
class MangoJuice extends Juice {}

interface ICakeMaker {//蛋糕制作者的职责
    Cake makeCake();
}

interface IJuiceMaker {//果汁制作者的职责
    Juice makeJuice();
}

interface IFoodMaker extends ICakeMaker, IJuiceMaker {}//每个人的职责

class XiaoMing implements IFoodMaker{//抽象工厂模式
    public Cake makeCake() {
        return new ChocolateCake();
    }

    public Juice makeJuice() {
        return new OrangeJuice();
    }
}

class XiaoLi implements IFoodMaker{
    public Cake makeCake() {
        return new MousseCake();
    }

    public Juice makeJuice() {
        return new AppleJuice();
    }
}

class XiaoZhang implements IFoodMaker{
    public Cake makeCake() {
        return new FruitCake();
    }

    public Juice makeJuice() {
        return new MangoJuice();
    }
}
public class Main {
    public static void main(String[] args) {
        IFoodMaker maker1 = new XiaoMing();
        IFoodMaker maker2 = new XiaoLi();
        IFoodMaker maker3 = new XiaoZhang();
      
        Cake xxxCake = maker1.makeCake();
        Juice xxxJuice = maker2.makeJuice();
        //...
    }
}
```

现在小明的开店模式可以适应增加任意多的新蛋糕，新果汁，增加任意多的员工，甚至能增加任意多的产品。小明家的美食吸引力真是大，经常会有其他街区的人前来品尝。小明想给自己的蛋糕店起一个名字，现在也不仅仅是蛋糕店了呢，就叫“小明美味加”吧，他的下一步打算是在全国开分店，在全中国打响自己的品牌。（完）

# 总结

小明的故事讲完了，其中涉及到工厂模式的三种情况，**简单工厂模式**，**工厂方法模式**，**抽象工厂模式**，它们的抽象程度依次增加，初始代码也越来越多，但是可扩展性越来越强。

> 三种工厂模式的本质都是工厂和产品的关系，区别在于对工厂和产品的抽象程度。

下面的UML图形象说明了这个关系，红色代表工厂，蓝色代表产品。

## 简单工厂模式

简单工厂模式仅仅是对产品进行了抽象，将产品的共性抽象成一个抽象类或者接口。

![简单工厂模式](http://7xs2xe.com1.z0.glb.clouddn.com/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png)

## 工厂方法模式

工厂方法模式不仅对产品进行了抽象，对工程也进行了抽象，把工厂生产的共性抽象出一个接口。

![工厂方法模式](http://7xs2xe.com1.z0.glb.clouddn.com/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png)

## 抽象工厂模式

抽象工厂模式对工厂方法模式的抽象又进一步升级，可以看做是把多个**工厂——产品**组合起来，在小明的例子中就是把蛋糕工厂和果汁工厂合并为一个工厂，这个工厂既可以生产蛋糕也可以生产果汁。

![抽象工厂模式](http://7xs2xe.com1.z0.glb.clouddn.com/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png)

以上就是我对工厂模式的理解，难免有疏漏，如果发现，请指出，谢谢~~