---
title: 由前序遍历，中序遍历和后序遍历确定一棵二叉树
date: 2016-04-14 20:15:44
tags:
  - 算法
  - 二叉树
  - 遍历
---

我们知道前序遍历和中序遍历，或者后序遍历和中序遍历可以唯一确定一棵二叉树，但是具体是如何生成的，如何用代码去实现呢？

### 题目1：由前序遍历和中序遍历求出后序遍历

思路：**从前往后**遍历前序数组，然后到中序遍历中寻找当前访问到的元素，以它为根生成节点，将中序数组分成左右两部分，**先左后右**递归地给节点左右子赋值。

首先给出节点的类定义：

``` Java
	class TreeNode {
        TreeNode left;
        TreeNode right;
        int val;

        TreeNode(int v) {
            val = v;
        }
    }
```

由前序和中序递归生成二叉树：

``` Java
    int[] pre = {9, 1, 2, 3, 5, 4, 7, 8};
    int[] mid = {9, 2, 3, 1, 7, 4, 8, 5};
    int pre_i = 0;//前序遍历的索引
    TreeNode buildTreeWithPreAndMid(int start, int end) {//参数分别代表中序数组子数组的起始结束位置
        if (start >= end) return null;
        TreeNode tn = new TreeNode(pre[pre_i]);
        pre_i++;
        for (int i = start; i < end; i++) {
            if (mid[i] == tn.val) {
                tn.left = buildTreeWithPreAndMid(start, i);
                tn.right = buildTreeWithPreAndMid(i + 1, end);
                break;
            }
        }
        return tn;
    }
```

### 题目2：由后序遍历和中序遍历求出前序遍历

思路：和前面类似，**从后往前**遍历后序数组，然后到中序遍历中寻找当前访问到的元素，以它为根生成节点，将中序数组分成左右两部分，**先右后左**递归地给节点左右子赋值。

``` Java
    int[] mid = {9, 2, 3, 1, 7, 4, 8, 5};
    int[] post = {3, 2, 7, 8, 4, 5, 1, 9};
    int post_i = post.length - 1;//后序遍历的索引
    TreeNode buildTreeWithPostAndMid(int start, int end) {
        if (start >= end) return null;
        TreeNode tn = new TreeNode(post[post_i]);
        post_i--;
        for (int i = start; i < end; i++) {
            if (mid[i] == tn.val) {
                tn.right = buildTreeWithPostAndMid(i + 1, end);
                tn.left = buildTreeWithPostAndMid(start, i);
                break;
            }
        }
        return tn;
    }
```
